simple_function <- function(x, y, z) {
expectedVal <- x*x + y*y
if (expectedVal == z)
return(TRUE)
else
return(FALSE)
}
simple_function(1,2,3)
simple_function(1,2,5)
#     a. How many missing values are in the `height` column?
#       [code completion + comprehension]
#
nrow(dogs[is.na(dogs$height), ])
#     a. How many missing values are in the `height` column?
#       [code completion + comprehension]
#
# returns number of rows that are NA (missing) in the height column.
# dogs[is.na(dogs$height), ] returns the rows with NA in the height column, and
# nrow returns the number of rows.
nrow(dogs[is.na(dogs$height), ])
# 6. Load the dogs data from the `dogs.rds` file provided in lecture.
#
# set directory to best_in_show so that I can access dogs.rds
setwd('/Users/haset/sts115_jozomaro/files_in_r/best_in_show')
dogs = read.rds('dogs.rds') # read dogs.rds
# 6. Load the dogs data from the `dogs.rds` file provided in lecture.
#
# set directory to best_in_show so that I can access dogs.rds
setwd('/Users/haset/sts115_jozomaro/files_in_r/best_in_show')
dogs = readRDS('dogs.rds') # read dogs.rds
#     a. How many missing values are in the `height` column?
#       [code completion + comprehension]
#
# returns number of rows that are NA (missing) in the height column.
# dogs[is.na(dogs$height), ] returns the rows with NA in the height column, and
# nrow returns the number of rows.
nrow(dogs[is.na(dogs$height), ])
dim(dogs[is.na(dogs$height), ])
sum(is.na(dogs$height))
#
#     c. Which column has the most missing values? Try to solve this by
#        implementing your strategy from part b. If that doesn't work, you can
#        use the `summary` function to get the number of missing values in each
#        column as well as a lot of other information (we'll discuss this
#        function more next week).
#       [code completion + comprehension]
maxNA <- 1;
for(i in 2:ncol(dogs)) { # for all columns of dogs
# print the number of missing values per each column by indexing dogs[,i]
if(sum(is.na(dogs[,i])) > sum(is.na(dogs[,maxNA]))) {
maxNA <- i;
}
}
print("Column ", maxNA, " has the most missing values.")
#
#     c. Which column has the most missing values? Try to solve this by
#        implementing your strategy from part b. If that doesn't work, you can
#        use the `summary` function to get the number of missing values in each
#        column as well as a lot of other information (we'll discuss this
#        function more next week).
#       [code completion + comprehension]
maxNA <- 1;
for(i in 2:ncol(dogs)) { # for all columns of dogs
# print the number of missing values per each column by indexing dogs[,i]
if(sum(is.na(dogs[,i])) > sum(is.na(dogs[,maxNA]))) {
maxNA <- i;
}
}
print("Column " + maxNA + " has the most missing values.")
#
#     c. Which column has the most missing values? Try to solve this by
#        implementing your strategy from part b. If that doesn't work, you can
#        use the `summary` function to get the number of missing values in each
#        column as well as a lot of other information (we'll discuss this
#        function more next week).
#       [code completion + comprehension]
maxNA <- 1;
for(i in 2:ncol(dogs)) { # for all columns of dogs
# print the number of missing values per each column by indexing dogs[,i]
if(sum(is.na(dogs[,i])) > sum(is.na(dogs[,maxNA]))) {
maxNA <- i;
}
}
print(paste("Column ", maxNA, " has the most missing values."))
View(dogs)
# 7. Use indexing to get the subset of the dogs data which only contains large
#    dogs that are good with kids (the category `high` in the `kids` column
#    means good with kids). [code completion + comprehension]
dogs[dogs$size == 'large' && dogs$kids == 'high', ]
# 7. Use indexing to get the subset of the dogs data which only contains large
#    dogs that are good with kids (the category `high` in the `kids` column
#    means good with kids). [code completion + comprehension]
dogs[dogs$size == 'large' & dogs$kids == 'high', ]
# 7. Use indexing to get the subset of the dogs data which only contains large
#    dogs that are good with kids (the category `high` in the `kids` column
#    means good with kids). [code completion + comprehension]
dogs[dogs$size == 'large' && dogs$kids == 'high', ]
# 7. Use indexing to get the subset of the dogs data which only contains large
#    dogs that are good with kids (the category `high` in the `kids` column
#    means good with kids). [code completion + comprehension]
#
# every row in dogs where size = large and kids = high, and neither is NA
dogs[dogs$size == 'large' & !is.na(dogs$size) & dogs$kids == 'high' & !is.na(dogs$size), ]
# 7. Use indexing to get the subset of the dogs data which only contains large
#    dogs that are good with kids (the category `high` in the `kids` column
#    means good with kids). [code completion + comprehension]
#
# every row in dogs where size = large and kids = high, and neither is NA
dogs[dogs$size == 'large' & !is.na(dogs$size) & dogs$kids == 'high' & !is.na(dogs$kids), ]
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
myVector <- logical(length = nrow(dogs))
for(i in 1:nrow(dogs)) {
if(dogs[i, c('grooming')] == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
for(i in 1:nrow(dogs)) {
myVal <- dogs[i, c('grooming')]
if(myVal == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
print(myVal <- dogs[i, c('grooming')])
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
myVector <- logical(length = nrow(dogs))
for(i in 1:nrow(dogs)) {
if(dogs[i & !is.na(dogs&grooming), c('grooming')] == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
myVector <- logical(length = nrow(dogs))
for(i in 1:nrow(dogs)) {
if(dogs[i & !is.na(dogs&grooming), dogs$grooming] == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
for(i in 1:nrow(dogs)) {
if(dogs[i & !is.na(dogs$grooming), c('grooming')] == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
for(i in 1:nrow(dogs)) {
print(dogs[i & !is.na(dogs$grooming), c('grooming')])
if(dogs[i & !is.na(dogs$grooming), c('grooming')] == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
myVector <- logical(length = nrow(dogs))
for(i in 1:nrow(dogs)) {
print(dogs[i:i & !is.na(dogs$grooming), c('grooming')])
if(dogs[i:i & !is.na(dogs$grooming), c('grooming')] == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
for(i in 1:nrow(dogs)) {
if(dogs[i & !is.na(dogs$grooming), c('grooming')] == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
print(dogs[1 & !is.na(dogs$grooming), c('grooming')])
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
myVector <- logical(length = nrow(dogs))
print(dogs[1:1 & !is.na(dogs$grooming), c('grooming')])
print(dogs[1, c('grooming')])
print(!is.na(dogs[1, c('grooming')]))
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
myVector <- logical(length = nrow(dogs))
for(i in 1:nrow(dogs)) {
if(!is.na(dogs[i, c('grooming')]) && dogs[i,c('grooming')] == 'daily') {
myVector[i] = TRUE
} else {
myVector[i] = FALSE
}
}
print(myVector)
print(myVector[23])
print(myVector[24])
print(myVector[11])
print(myVector[10])
#     b. Use the condition from part a to get the subset of all rows containing
#        dogs that need daily grooming. How many rows are there?
#       [code completion + comprehension]
#
mySubset = dogs[myVector,]
print mySubset
#     b. Use the condition from part a to get the subset of all rows containing
#        dogs that need daily grooming. How many rows are there?
#       [code completion + comprehension]
#
mySubset = dogs[myVector,]
print(mySubset)
View(mySubset)
nrow(mySubset) # get number of rows in the rows subset
#     c. Use the `table` function to compute the number of dogs in each
#        grooming category. You should see a different count than in part b for
#        daily grooming. What do you think is the reason for this difference?
#       [code completion + interpretation]
#
table(dogs$grooming)
# the table function. However, this was probably because I checked for NA values
# in part b. If I had not done that, then my vector would have included the
# missing values. Table ignores missing values.
#
#     d. Enclose the condition from part a in a call to the `which` function,
#        and then use it to get the subset of all rows containing dogs that
#        need daily grooming. Now how many rows are there? Does the number of
#        rows agree with the count in part c?
#       [code completion + comprehension]
#
which(!is.na(dogs[i, c('grooming')]) && dogs[i,c('grooming')] == 'daily')
# the table function. However, this was probably because I checked for NA values
# in part b. If I had not done that, then my vector would have included the
# missing values. Table ignores missing values.
#
#     d. Enclose the condition from part a in a call to the `which` function,
#        and then use it to get the subset of all rows containing dogs that
#        need daily grooming. Now how many rows are there? Does the number of
#        rows agree with the count in part c?
#       [code completion + comprehension]
#
which(!is.na(dogs[, c('grooming')]) && dogs[,c('grooming')] == 'daily')
# the table function. However, this was probably because I checked for NA values
# in part b. If I had not done that, then my vector would have included the
# missing values. Table ignores missing values.
#
#     d. Enclose the condition from part a in a call to the `which` function,
#        and then use it to get the subset of all rows containing dogs that
#        need daily grooming. Now how many rows are there? Does the number of
#        rows agree with the count in part c?
#       [code completion + comprehension]
#
which(dogs$grooming == 'daily')
myVector2 = (dogs$grooming == 'daily')
print(myVector2)
print(myVector)
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
# logical vector that is true when the grooming column is 'daily'
myVector <- (dogs$grooming == 'daily')
print(myVector)
#     b. Use the condition from part a to get the subset of all rows containing
#        dogs that need daily grooming. How many rows are there?
#       [code completion + comprehension]
#
# Use myVector, which holds TRUE values for all daily grooming dogs after
# going through the conditional statement in part a. dogs[myVector, ] returns
# the subset of all rows in dogs were myVector is TRUE or NA
mySubset <- dogs[myVector,]
nrow(mySubset) # get number of rows in the subset of rows
# 6. Load the dogs data from the `dogs.rds` file provided in lecture.
#
# set directory to best_in_show so that I can access dogs.rds
setwd('/Users/haset/sts115_jozomaro/files_in_r/best_in_show')
dogs <- readRDS('dogs.rds') # read dogs.rds
#     a. How many missing values are in the `height` column?
#       [code completion + comprehension]
#
# returns number of rows that are NA (missing) in the height column.
# dogs[is.na(dogs$height), ] returns the rows with NA in the height column, and
# nrow returns the number of rows.
nrow(dogs[is.na(dogs$height), ])
#
#     b. Think of a strategy to check the number of missing values in every
#        column using no more than 3 lines of code. Hint: think about last
#        week's lecture. Explain your strategy in words.
#       [code completion + comprehension]
for(i in 1:ncol(dogs)) { # for all columns of dogs
# print the number of missing values per each column by indexing dogs[,i]
print(sum(is.na(dogs[,i])))
}
#
#     c. Which column has the most missing values? Try to solve this by
#        implementing your strategy from part b. If that doesn't work, you can
#        use the `summary` function to get the number of missing values in each
#        column as well as a lot of other information (we'll discuss this
#        function more next week).
#       [code completion + comprehension]
maxNA <- 1; #maxNA stores 1 for column 1
for(i in 2:ncol(dogs)) { # for all columns of dogs, except the first column
# check if the current column i has more NA values than our maxNA column
if(sum(is.na(dogs[,i])) > sum(is.na(dogs[,maxNA]))) {
maxNA <- i; # if i has more NA values than maxNA, make maxNA equal to i
}
}
print(paste("Column ", maxNA, " has the most missing values.")) # print maxNA
# 7. Use indexing to get the subset of the dogs data which only contains large
#    dogs that are good with kids (the category `high` in the `kids` column
#    means good with kids). [code completion + comprehension]
#
# every row in dogs where size = large and kids = high, and neither is NA
# !is.na(dogs$columnName) makes sure we don't get NA values
dogs[dogs$size == 'large' & !is.na(dogs$size) & dogs$kids == 'high' & !is.na(dogs$kids), ]
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
# logical vector that is true when the grooming column is 'daily'
myVector <- (dogs$grooming == 'daily')
print(myVector)
#     b. Use the condition from part a to get the subset of all rows containing
#        dogs that need daily grooming. How many rows are there?
#       [code completion + comprehension]
#
# Use myVector, which holds TRUE values for all daily grooming dogs after
# going through the conditional statement in part a. dogs[myVector, ] returns
# the subset of all rows in dogs were myVector is TRUE or NA
mySubset <- dogs[myVector,]
nrow(mySubset) # get number of rows in the subset of rows
#     c. Use the `table` function to compute the number of dogs in each
#        grooming category. You should see a different count than in part b for
#        daily grooming. What do you think is the reason for this difference?
#       [code completion + interpretation]
#
table(dogs$grooming) # get the count of dogs in each grooming category
view(mySubset)
View(mySubset)
# 6. Load the dogs data from the `dogs.rds` file provided in lecture.
#
# set directory to best_in_show so that I can access dogs.rds
setwd('/Users/haset/sts115_jozomaro/files_in_r/best_in_show')
dogs <- readRDS('dogs.rds') # read dogs.rds
#     a. How many missing values are in the `height` column?
#       [code completion + comprehension]
#
# returns number of rows that are NA (missing) in the height column.
# dogs[is.na(dogs$height), ] returns the rows with NA in the height column, and
# nrow returns the number of rows.
nrow(dogs[is.na(dogs$height), ])
#
#     b. Think of a strategy to check the number of missing values in every
#        column using no more than 3 lines of code. Hint: think about last
#        week's lecture. Explain your strategy in words.
#       [code completion + comprehension]
for(i in 1:ncol(dogs)) { # for all columns of dogs
# print the number of missing values per each column by indexing dogs[,i]
print(sum(is.na(dogs[,i])))
}
#
#     c. Which column has the most missing values? Try to solve this by
#        implementing your strategy from part b. If that doesn't work, you can
#        use the `summary` function to get the number of missing values in each
#        column as well as a lot of other information (we'll discuss this
#        function more next week).
#       [code completion + comprehension]
maxNA <- 1; #maxNA stores 1 for column 1
for(i in 2:ncol(dogs)) { # for all columns of dogs, except the first column
# check if the current column i has more NA values than our maxNA column
if(sum(is.na(dogs[,i])) > sum(is.na(dogs[,maxNA]))) {
maxNA <- i; # if i has more NA values than maxNA, make maxNA equal to i
}
}
print(paste("Column ", maxNA, " has the most missing values.")) # print maxNA
# 7. Use indexing to get the subset of the dogs data which only contains large
#    dogs that are good with kids (the category `high` in the `kids` column
#    means good with kids). [code completion + comprehension]
#
# every row in dogs where size = large and kids = high, and neither is NA
# !is.na(dogs$columnName) makes sure we don't get NA values
dogs[dogs$size == 'large' & !is.na(dogs$size) & dogs$kids == 'high' & !is.na(dogs$kids), ]
# 8. With the dogs data:
#
#     a. Write the condition to test which dogs need daily grooming (the result
#        should be a logical vector). Does it contain missing values?
#       [code completion + comprehension]
#
# logical vector that is true when the grooming column is 'daily'
myVector <- (dogs$grooming == 'daily')
print(myVector)
#     b. Use the condition from part a to get the subset of all rows containing
#        dogs that need daily grooming. How many rows are there?
#       [code completion + comprehension]
#
# Use myVector, which holds TRUE values for all daily grooming dogs after
# going through the conditional statement in part a. dogs[myVector, ] returns
# the subset of all rows in dogs were myVector is TRUE or NA
mySubset <- dogs[myVector,]
nrow(mySubset) # get number of rows in the subset of rows
#     c. Use the `table` function to compute the number of dogs in each
#        grooming category. You should see a different count than in part b for
#        daily grooming. What do you think is the reason for this difference?
#       [code completion + interpretation]
#
table(dogs$grooming) # get the count of dogs in each grooming category
# count included dogs that had a missing grooming value. The table function
# ignores missing values and only counts dogs that have 'dialy' as the grooming
# value.
#
#     d. Enclose the condition from part a in a call to the `which` function,
#        and then use it to get the subset of all rows containing dogs that
#        need daily grooming. Now how many rows are there? Does the number of
#        rows agree with the count in part c?
#       [code completion + comprehension]
#
which(dogs$grooming == 'daily')
mySubset2 <- dogs[which(dogs$grooming == 'daily'),]
View(mySubset2)
nrow(mySubset2)
# 9. Compute a table that shows the number of dogs in each grooming category
#    versus size. Does it seem like size is related to how often dogs need to
#    be groomed? Explain your reasoning. [code completion + interpretation]
#
table(dogs$grooming, dogs$size)
# 10. Compute the number of dogs in the `terrier` group in two different ways:
#
#     a. By making a table from the `group` column.
#       [code completion + comprehension]
table(dogs$group)
# 23 terriers
#
#     b. By getting a subset of only terriers and counting the rows.
#       [code completion + comprehension]
#
# subset of dogs when the group equals 'terrier'
mySubset3 <- dogs[which(dogs$group == 'terrier'),]
nrow(mySubset3) # number of rows in the subset
# 10. Compute the number of dogs in the `terrier` group in two different ways:
#
#     a. By making a table from the `group` column.
#       [code completion + comprehension]
#
table(dogs$group) # number of dogs per each group value
# 28 terriers
#
#     b. By getting a subset of only terriers and counting the rows.
#       [code completion + comprehension]
#
# subset of dogs when the group equals 'terrier'
mySubset3 <- dogs[which(dogs$group == 'terrier'),]
nrow(mySubset3) # number of rows in the subset
#
#     c. Computing the table is simpler (in terms of code) and provides more
#        information. In spite of that, when would indexing (approach b) be more
#        useful? [comprehension + interpretation]
#
# Indexing would be more useful if we want to actually work with the data of
# rows that have a specific column value. The table function simply gives us a
# count of the number of rows that have certain column values, however, it does
# not allow us to access the specific values in those rows. If we want to modify
# the data or extract elements from it, we would prefer to use indexing.
